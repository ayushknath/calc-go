package lexer

import (
	"fmt"
	"slices"
	"testing"
)

func TestTokenizerValid(t *testing.T) {
	var tests = []struct {
		input  string
		tokens []string
	}{
		{"2.5 + 3.1", []string{"2.5", "+", "3.1"}},
		{"(1.2 + 3.4) * 2", []string{"(", "1.2", "+", "3.4", ")", "*", "2"}},
		{"4.0 / 2", []string{"4.0", "/", "2"}},
		{"(2.5 * (3.2 + 1.8))", []string{"(", "2.5", "*", "(", "3.2", "+", "1.8", ")", ")"}},
		{"3.14 * (2 + 1.86)", []string{"3.14", "*", "(", "2", "+", "1.86", ")"}},
		{"(0.5 + 0.5) * (2.0 - 1.0)", []string{"(", "0.5", "+", "0.5", ")", "*", "(", "2.0", "-", "1.0", ")"}},
		{"10.0 / (5.0 - 2.5)", []string{"10.0", "/", "(", "5.0", "-", "2.5", ")"}},
		{"(3 + 2.0) ** 2", []string{"(", "3", "+", "2.0", ")", "**", "2"}},
		{"2.5 ** (1 + 1)", []string{"2.5", "**", "(", "1", "+", "1", ")"}},
		{"((1.1 + 2.2) * (3.3 - 4.4)) / 5.5", []string{"(", "(", "1.1", "+", "2.2", ")", "*", "(", "3.3", "-", "4.4", ")", ")", "/", "5.5"}},
	}

	for _, tt := range tests {
		testname := fmt.Sprintf("%q", tt.input)
		t.Run(testname, func(t *testing.T) {
			ans := Tokenize(tt.input)
			if !slices.Equal(ans, tt.tokens) {
				t.Errorf("got %q, want %q", ans, tt.tokens)
			}
		})
	}
}

func TestTokenizerInvalid(t *testing.T) {
	var tests = []struct {
		input  string
		tokens []string
	}{
		{"2 + * 3", []string{"2", "+", "*", "3"}},
		{"5 + (7 - 2", []string{"5", "+", "(", "7", "-", "2"}},
		{"(2 + 3))", []string{"(", "2", "+", "3", ")", ")"}},
		{"2 (3 + 4)", []string{"2", "(", "3", "+", "4", ")"}},
		{"()", []string{"(", ")"}},
		{"3 + ()", []string{"3", "+", "(", ")"}},
		{"* 3 + 2", []string{"*", "3", "+", "2"}},
		{"3 + 2 -", []string{"3", "+", "2", "-"}},
		{"(3 + 2))(", []string{"(", "3", "+", "2", ")", ")", "("}},
		{"(2 + (3 * (4 - 1))", []string{"(", "2", "+", "(", "3", "*", "(", "4", "-", "1", ")", ")"}},

		{"2.5 + * 3.1", []string{"2.5", "+", "*", "3.1"}},
		{"(1.2 + 3.4", []string{"(", "1.2", "+", "3.4"}},
		{"(4.0 / 2))", []string{"(", "4.0", "/", "2", ")", ")"}},
		{"3.14 (2 + 1.86)", []string{"3.14", "(", "2", "+", "1.86", ")"}},
		{"(0.5 + 0.5) * (2.0 - )", []string{"(", "0.5", "+", "0.5", ")", "*", "(", "2.0", "-", ")"}},
		{"* (5.0 - 2.5)", []string{"*", "(", "5.0", "-", "2.5", ")"}},
		{"(3 + 2.0)) (1 + 1)", []string{"(", "3", "+", "2.0", ")", ")", "(", "1", "+", "1", ")"}},
		{"(2.5 ** ) 3", []string{"(", "2.5", "**", ")", "3"}},
		{"3.0 + ()", []string{"3.0", "+", "(", ")"}},

		{"3..4 + 2", []string{"3..4", "+", "2"}},
		{"2.3.5 + 1", []string{"2.3.5", "+", "1"}},
		{"(1.2.3 + 4)", []string{"(", "1.2.3", "+", "4", ")"}},
		{"0..5 * 2", []string{"0..5", "*", "2"}},
		{"(3. + .4)", []string{"(", "3.", "+", ".4", ")"}},
	}

	for _, tt := range tests {
		testname := fmt.Sprintf("%q", tt.input)
		t.Run(testname, func(t *testing.T) {
			ans := Tokenize(tt.input)
			if !slices.Equal(ans, tt.tokens) {
				t.Errorf("got %q, want %q", ans, tt.tokens)
			}
		})
	}
}
